var Promise = require('promise'),
    http = require('http'),
    https = require('https'),
    urlParser = require('url'),
    qs = require('querystring');

function Response(response, buffer) {
    this._buffer = buffer;
    this._nativeResponse = response;
}

Response.prototype.getNativeResonse = function () {
    return this._nativeResponse;
};

Response.prototype.getStatusCode = function () {
    return this._nativeResponse.statusCode;
};

Response.prototype.getBuffer = function () {
    return this._buffer;
};

Response.prototype.getData = function () {
    return String(this._buffer);
};

Response.prototype.getJSON = function () {
    return JSON.parse(this.getData());
};

Response.prototype.request = function (options) {
    options.cookies = this.getNativeResonse().headers['set-cookie'].map(function (cookie) {
        return cookie.split(';')[0].trim();
    });
    return request(options);
};

function encodeFieldPart(boundary, name, value) {
    var returnPart = '--' + boundary + '\r\n';
    returnPart += 'Content-Disposition: form-data; name="' + name + '"\r\n\r\n';
    returnPart += value + '\r\n';
    return returnPart;
}

function encodeFilePart(boundary, type, name, filename) {
    /* jshint maxlen: 160 */
    var returnPart = '--' + boundary + '\r\n';
    returnPart += 'Content-Disposition: form-data; name="' + name + '"; filename="' + filename + '"\r\n';
    returnPart += 'Content-Type:' + type + '\r\n\r\n';
    return returnPart;
}

function constructRequestOptions(options) {
    /* jshint maxlen: 170, maxcomplexity:13 */
    var url = urlParser.parse(options.url),
        requestOptions = {
            hostname: url.hostname,
            method: options.method || 'GET',
            path: url.path,
            port: (url.protocol === 'https:') ? '443' : '80',
            headers: options.headers || {}
        },
        boundary;

    if (url.port) {
        requestOptions.port = url.port;
    }

    if (options.files) {
        boundary = Math.random();
        requestOptions.data = [];

        requestOptions.headers['Content-Type'] = 'multipart/form-data; boundary=' + boundary;

        if (options.parameters) {
            Object.keys(options.parameters).forEach(function (name) {
                var value = options.parameters[name];
                requestOptions.data.push(new Buffer(encodeFieldPart(boundary, name, value), 'ascii'));
            });

            Object.keys(options.files).forEach(function (name) {
                var value = options.files[name];
                requestOptions.data.push(new Buffer(encodeFilePart(boundary, value.type, name, value.name), 'ascii'));
                requestOptions.data.push(new Buffer(value.data, 'binary'));
            });

            requestOptions.data.push(new Buffer('\r\n--' + boundary + '--'), 'ascii');
        }
    } else {
        if (options.parameters) {
            requestOptions.data = qs.stringify(options.parameters);
            requestOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded';
        }
    }

    if (options.data) {
        requestOptions.data = options.data;
    }

    if (requestOptions.data) {
        if (Array.isArray(requestOptions.data)) {
            requestOptions.headers['Content-Length'] = 0;
            requestOptions.data.forEach(function (part) {
                requestOptions.headers['Content-Length'] += part.length;
            });
        } else {
            requestOptions.headers['Content-Length'] = requestOptions.data.length;
        }
    }

    if (options.cookies) {
        if (!requestOptions.headers) {
            requestOptions.headers = {};
        }
        requestOptions.headers.Cookie = options.cookies.join('; ');
    }

    return requestOptions;
}

function request(options) {
    var requestOptions = constructRequestOptions(options);

    return new Promise(function (resolve, reject) {
        var buffer,
            transport = http,
            request;

        if (urlParser.parse(options.url).protocol === 'https:') {
            transport = https;
        }

        request = transport.request(requestOptions, function (response) {

            if (options.encoding) {
                response.setEncoding(options.encoding);
            }

            response.on('data', function (chunk) {
                if (buffer) {
                    buffer = Buffer.concat([buffer, chunk]);
                } else {
                    buffer = chunk;
                }
            });

            response.on('error', function (error) {
                reject(error);
            });

            response.on('close', function () {
                reject(new Error('Connection closed'));
            });

            response.on('end', function () {
                resolve(new Response(response, buffer));
            });
        });

        request.on('error', function (error) {
            reject(error);
        });

        request.setTimeout(120000, function () {
            reject(new Error('Connection timeout'));
        });

        if (requestOptions.data) {
            if (Array.isArray(requestOptions.data)) {
                requestOptions.data.forEach(function (part) {
                    request.write(part);
                });
            } else {
                request.write(requestOptions.data);
            }
        }

        request.end();
    });
}

module.exports.request = request;